import dedent from 'dedent'

import config from '../config'
import { camelCaseToPascalCase, toKebabCase } from './str'

import * as I from '../types'

type AdapterModuleFile = {
  filePath: string
  body: string
}

type ConnectorFunction = {
  /**
   * @example 'textToText'
   * @example 'textToAudio'
   * @example 'audioToVideo'
   **/
  transformation: I.Transformation

  /**
   * @example 'string'
   * @example 'number'
   * @example 'chatMessage'
   **/
  inputKey: string
  /**
   * @example 'string'
   * @example 'number'
   * @example 'chatMessage'
   **/
  outputKey: string

  /**
   * @example '(keys: Keys, options: Options, unit: string) => StreamOf<ChatMessage>'
   **/
  fnType: string
}

type IOPrimitive = {
  /**
   * @example 'string'
   * @example 'stringArr'
   * @example 'stringArrStream'
   * @example 'chatMessage'
   **/
  key: string

  /**
   * @example 'string'
   * @example 'Array<string>'
   * @example 'StreamOf<Array<string>>'
   * @example 'ChatMessageUnit'
   **/
  typings: string

  /* Representation of the `ObjectUnitSchema` */
  objectUnit?: {
    /**
     * @example 'ChatMessageUnit'
     * @example 'AnnotatedImageUnit'
     * @example 'SongWithLyricsUnit'
     * @example 'VideoWithSubtitlesUnit`
     **/
    id: string

    /**
     * @example
     *
     * ```
     * export ChatMessageUnit = {
     *   id: 'chatMessage'
     *   payload: string
     *   role: 'assistant' | 'system'
     * }
     * ```
     **/
    typings: string
  }
}

/**
 * The structure used for connector signature and typings generation
 **/
type ConnectorTypingsStructure = Record<
  string /* transformation type */,
  Record<
    string /* unit input type */,
    Record<string /* unit output type */, string /* function type */>
  >
>

export const STREAM_SUFFIX = 'Stream'
export const ARRAY_SUFFIX = 'Arr'

const GENERATED_FILE_HEAD_COMMENT = dedent(` 
  /**
   * The file is generated by SPADAR CLI v. ${config.version}
   * DO NOT EDIT IT MANUALLY because it could be automatically rewritten
   **/`)

const REQUIRED_PROPERTY_SCHEMA = new Set<I.RequiredPayloadPropSchema>([
  'Buffer',
  'string',
  'number',
  'boolean',
])

/* Transform `PropertySchema` to type */
export const propertyToType = (property: I.PropSchema): string => {
  switch (property) {
    case 'Buffer':
    case 'string':
    case 'number':
    case 'boolean':
      return property

    default: {
      if (property.type === 'stringUnion') {
        if (typeof property.of === 'string') {
          return `'${property.of}'`
        }

        const type = property.of.map((x) => `'${x}'`).join(' | ')

        return type
      }

      return property.type
    }
  }
}

export const unitSchemaToType = (unitSchema: I.UnitSchema): string => {
  if (typeof unitSchema !== 'object') {
    return propertyToType(unitSchema)
  }

  const keyValuePair = Object.keys(unitSchema).map((key) => {
    const propertySchema = unitSchema[key]
    const valueType = (() => {
      if (typeof propertySchema === 'string') {
        if (
          REQUIRED_PROPERTY_SCHEMA.has(
            propertySchema as I.RequiredPayloadPropSchema
          )
        ) {
          return propertyToType(propertySchema as I.PropSchema)
        }

        return `'${propertySchema}'`
      }

      return propertyToType(propertySchema)
    })()

    const optionalSymbol = ((): string => {
      if (typeof propertySchema !== 'object') return ''
      if (propertySchema.required) return ''

      return '?'
    })()

    return `${key}${optionalSymbol}: ${valueType}`
  })

  const unitId = camelCaseToPascalCase(unitSchema.id + 'Unit')

  const result = dedent(`
    export type ${unitId} = {
      ${keyValuePair.join('\n      ')}
    }
  `)

  return result
}

export const generateIOPrimitive = (
  transferMethod: I.TransferMethod,
  ioType: 'input' | 'output',
  ioUnitSchema: I.IOUnitSchema
): IOPrimitive => {
  const arrSuffix = Array.isArray(ioUnitSchema) ? ARRAY_SUFFIX : ''
  const isStream = ((): boolean => {
    switch (transferMethod) {
      case 'streamInStreamOut':
        return true
      case 'staticInStaticOut':
        return false
      case 'streamInStaticOut':
        return ioType === 'input'
      case 'staticInStreamOut':
        return ioType === 'output'
    }
  })()

  const streamSuffix = isStream ? STREAM_SUFFIX : ''
  const streamOfWrapper = (type: string) => {
    return isStream ? `StreamOf<${type}>` : type
  }

  const suffix = arrSuffix + streamSuffix
  const unitSchema = Array.isArray(ioUnitSchema)
    ? ioUnitSchema[0]
    : ioUnitSchema

  const unitKey = (() => {
    if (typeof unitSchema !== 'object') {
      switch (unitSchema) {
        case 'Buffer':
          return 'buffer'
        case 'string':
          return 'string'
      }
    } else {
      return unitSchema.id
    }
  })()

  const key = unitKey + suffix

  const objectUnit = ((): { id: string; typings: string } | undefined => {
    if (typeof unitSchema !== 'object' || Array.isArray(unitSchema)) {
      return undefined
    }

    const id = camelCaseToPascalCase(unitKey) + 'Unit'
    const typings = unitSchemaToType(unitSchema)

    return { id, typings }
  })()

  const unitTypings = unitSchemaToType(unitSchema)

  const typings = streamOfWrapper(
    (objectUnit ? objectUnit.id : unitTypings) +
      (Array.isArray(ioUnitSchema) ? '[]' : '')
  )

  return { key, typings, objectUnit }
}

export const getFunctionsAndUnits = (
  supportedIO: I.TransformationIOSchema[]
) => {
  return supportedIO.reduce<{
    unitIds: Set<string>
    unitTypings: string[]
    functions: ConnectorFunction[]
  }>(
    (acc, transformationSchema) => {
      const transferMethods = Object.keys(
        transformationSchema.io
      ) as I.TransferMethod[]

      transferMethods.forEach((transferMethod) => {
        const ioSchemas = transformationSchema.io[transferMethod]

        if (!ioSchemas) return

        ioSchemas.forEach(([inputSchema, outputSchema]) => {
          const inputUnit = generateIOPrimitive(
            transferMethod,
            'input',
            inputSchema
          )

          const outputUnit = generateIOPrimitive(
            transferMethod,
            'output',
            outputSchema
          )

          const fnType = `(secrets: Secrets, options: Options, unit: ${inputUnit.typings}) => Promise<${outputUnit.typings}>`

          acc.functions.push({
            transformation: transformationSchema.type,
            inputKey: inputUnit.key,
            outputKey: outputUnit.key,
            fnType,
          })

          const primitives = [inputUnit, outputUnit]

          primitives.forEach((primitive) => {
            if (!primitive.objectUnit) return
            if (acc.unitIds.has(primitive.objectUnit.id)) return

            acc.unitIds.add(primitive.objectUnit.id)
            acc.unitTypings.push(primitive.objectUnit.typings)
          })
        })
      })

      return acc
    },
    { functions: [], unitIds: new Set(), unitTypings: [] }
  )
}

export const getConnectorFiles = (
  schema: I.ConnectorSchema
): {
  [k in 'connector' | 'signature' | 'typings']: AdapterModuleFile
} => {
  const { unitTypings, functions } = getFunctionsAndUnits(schema.supportedIO)

  const structure = functions.reduce<ConnectorTypingsStructure>((acc, fn) => {
    acc[fn.transformation] = acc[fn.transformation] || {}
    acc[fn.transformation][fn.inputKey] =
      acc[fn.transformation][fn.inputKey] || {}

    acc[fn.transformation][fn.inputKey][fn.outputKey] = fn.fnType

    return acc
  }, {})

  let connectorTypingsTail = 'export type Connector = {'
  let connectorSignature =
    GENERATED_FILE_HEAD_COMMENT +
    '\n\n' +
    dedent(`
      import Connector from './${toKebabCase(schema.id)}.typings'
      
      export const connector: Connector = {
  `)

  const signatureWriter = (x: string) => {
    connectorTypingsTail += x
    connectorSignature += x
  }

  Object.keys(structure).forEach((transformation) => {
    signatureWriter(`\n  ${transformation}: {`)

    Object.keys(structure[transformation]).forEach((inputKey) => {
      signatureWriter(`\n    ${inputKey}: {`)

      Object.keys(structure[transformation][inputKey]).forEach((outputKey) => {
        const fnType = structure[transformation][inputKey][outputKey]
        const comment = `/* ${inputKey} -> ${outputKey};  */`

        signatureWriter(`\n      ${comment}`)

        connectorTypingsTail += `\n      ${outputKey}: ${fnType}`
        connectorSignature += `\n      ${outputKey}: () => throw new Error('Not implemented')`
      })

      signatureWriter(`\n    }`)
    })
  })

  signatureWriter('\n  }')
  signatureWriter('\n}')

  connectorTypingsTail += '\n\nexport default Connector'
  connectorSignature += '\n\nexport default connector'

  const optionsPropList = Object.keys(schema.options).map((key) => {
    return `${key}: ${propertyToType(schema.options[key])}`
  })

  const optionsType = dedent(`
      export type Options = {
        ${optionsPropList.join('\n  ')}
      }
    `)

  const keysPropList = schema.keys.map(({ key }) => {
    return `${key}: string`
  })

  const keysTypings = dedent(`
      export type Keys = {
        ${keysPropList.join('\n  ')}
      }
    `)

  const connectorTypings = [
    GENERATED_FILE_HEAD_COMMENT,
    keysTypings,
    optionsType,
    ...unitTypings,
    connectorTypingsTail,
  ]
    .filter((x) => !!x.trim())
    .join('\n\n')
    .trim()

  return {
    typings: {
      filePath: config.adapter.connectorTypingsFilePath(schema.id),
      body: connectorTypings,
    },
    signature: {
      filePath: config.adapter.connectorSignaturePath(schema.id),
      body: connectorSignature,
    },
    // FIXME: implement connector
    connector: { filePath: '', body: '' },
  }
}

// FIXME: add unit tests for the function
export const schemaToAdapterFiles = (
  adapterModule: {
    name: string
    version: string
  },
  connectorSchemas: I.ConnectorSchema[]
): AdapterModuleFile[] => {
  const adapterFiles: AdapterModuleFile[] = []

  const adapterEntryHeadLines: string[] = []
  const adapterEntryTailLines: string[] = ['export default {']

  connectorSchemas.forEach((connectorSchema, index) => {
    const connectorFiles = getConnectorFiles(connectorSchema)

    /* We avoiding possible name collisions */
    const importedConnectorName = `connector${index}`

    // TODO: this is relative path from adapter entry point
    //       to connector which is not connected to `config.adapter`
    //       so if the config is changed we will have an error here
    adapterEntryHeadLines.push(
      `import ${importedConnectorName} from './connectors/${toKebabCase(
        connectorSchema.id
      )}.ts'`
    )

    adapterEntryTailLines.push(
      `  "${connectorSchema.id}": ${importedConnectorName},`
    )

    adapterFiles.push(connectorFiles.typings)
    adapterFiles.push(connectorFiles.signature)
    adapterFiles.push(connectorFiles.connector)
  })

  adapterEntryTailLines.push('}')

  const adapterEntryFileLine: string[] = adapterEntryHeadLines.concat(
    adapterEntryTailLines
  )

  adapterFiles.push({
    filePath: config.adapter.adapterEntryPoint,
    body: adapterEntryFileLine.join('\n'),
  })

  return adapterFiles
}
